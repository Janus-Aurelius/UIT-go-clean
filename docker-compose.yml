# ============================================================================
# docker-compose.yml - Unified Configuration for Architectural Comparison
# ============================================================================
# Purpose: Fair comparison between pre-improvement and post-improvement
#          architectures with IDENTICAL resource constraints.
#
# Resource Allocation: MODERATE tier (2.5 CPUs, 4GB memory)
# Replicas: 1 per service (for both scenarios)
# Architecture: Toggle between scenarios using environment variables or configs
#
# This ensures performance differences are purely architectural, not resource-based.
# ============================================================================

services:
  # Redis - Caching and geospatial indexing (THE BOTTLENECK)
  # ⚠️ KEEP CPU LOW to ensure Redis is the bottleneck for driver matching algorithm tests
  # ✅ Connected to app-monitor-net for observability stack access
  redis:
    image: redis:7-alpine
    container_name: redis
    ports:
      - "6379:6379"  # ✅ Exposed to host for seed-ghost-drivers.js access
    networks:
      - uit-go-network      # ✅ Internal app services
      - app-monitor-net     # ✅ Observability stack (Prometheus, Grafana, load tests)
    deploy:
      replicas: 1
      resources:
        limits:
          cpus: '0.5'        # ⚠️ Keep low - this is the bottleneck we want to test
          memory: 256M       # ✅ Reduced from 512M (100k keys = ~50MB, 256M is plenty)
        reservations:
          cpus: '0.25'
          memory: 128M
    mem_swappiness: 0
    command: redis-server --maxmemory 200mb --maxmemory-policy allkeys-lru
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 5
    restart: unless-stopped

  # API Gateway - Entry point
  api-gateway:
    build:
      context: .
      dockerfile: apps/api-gateway/Dockerfile
    ports:
      - "3000:3000"
    env_file:
      - ./apps/api-gateway/.env
    environment:
      - USER_GRPC_URL=user-service:50051
      - DRIVER_GRPC_URL=driver-service:50052
      - TRIP_GRPC_URL=trip-service:50053
      - NODE_ENV=production
      - LOG_LEVEL=${LOG_LEVEL:-info}
    depends_on:
      redis:
        condition: service_healthy
      user-service:
        condition: service_started
      driver-service:
        condition: service_started
      trip-service:
        condition: service_started
    networks:
      - uit-go-network
      - app-monitor-net  # ✅ Added for observability/k6 access
    deploy:
      replicas: 1
      resources:
        limits:
          cpus: '0.5'
          memory: 300M       # ✅ Reduced from 1024M to fit 4GB RAM host
        reservations:
          cpus: '0.25'
          memory: 150M
    mem_swappiness: 0
    restart: unless-stopped

  # User Service
  user-service:
    build:
      context: .
      dockerfile: apps/user-service/Dockerfile
    environment:
      - USER_GRPC_URL=0.0.0.0:50051
      - DRIVER_GRPC_URL=driver-service:50052
      - TRIP_GRPC_URL=trip-service:50053
      - NODE_ENV=production
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - DATABASE_CONNECTION_LIMIT=2  # ⚠️ Critical for NeonDB free tier (2 * 3 replicas = 6 conn)
    env_file:
      - ./apps/user-service/.env
    # ports:
    #   - "50051:50051"  # ❌ Disabled for scaling (avoids port conflicts)
    networks:
      - uit-go-network
    deploy:
      replicas: 3  # ✅ Scaled to 3 instances for load balancing
      resources:
        limits:
          cpus: '0.6'                # ✅ High CPU to hammer Redis
          memory: 300M               # ✅ Reduced from 768M to fit 4GB RAM host
        reservations:
          cpus: '0.25'
          memory: 150M
    mem_swappiness: 0
    restart: unless-stopped

  # Driver Service - Handles geospatial queries (HIGH CPU TO STRESS REDIS)
  driver-service:
    build:
      context: .
      dockerfile: apps/driver-service/Dockerfile
    environment:
      - DRIVER_GRPC_URL=0.0.0.0:50052
      - REDIS_URL=redis://redis:6379
      - MQTT_BROKER_URL=mqtt://mosquitto:1883
      - USER_GRPC_URL=user-service:50051
      - TRIP_GRPC_URL=trip-service:50053
      - NODE_ENV=production
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - DATABASE_CONNECTION_LIMIT=2  # ⚠️ Critical for NeonDB free tier (2 * 3 replicas = 6 conn)
    env_file:
      - ./apps/driver-service/.env
    # ports:
    #   - "50052:50052"  # ❌ Disabled for scaling (avoids port conflicts)
    depends_on:
      redis:
        condition: service_healthy
      mosquitto:
        condition: service_healthy
    networks:
      - uit-go-network
    deploy:
      replicas: 3  # ✅ Scaled to 3 instances for load balancing
      resources:
        limits:
          cpus: '0.6'                # ✅ High CPU to hammer Redis bottleneck
          memory: 350M               # ✅ Reduced from 1024M to fit 4GB RAM host
        reservations:
          cpus: '0.25'
          memory: 200M
    mem_swappiness: 0
    restart: unless-stopped

  # Trip Service - Orchestrates trip lifecycle
  trip-service:
    build:
      context: .
      dockerfile: apps/trip-service/Dockerfile
    environment:
      - TRIP_GRPC_URL=0.0.0.0:50053
      - USER_GRPC_URL=user-service:50051
      - DRIVER_GRPC_URL=driver-service:50052
      - NODE_ENV=production
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - DATABASE_CONNECTION_LIMIT=2  # ⚠️ Critical for NeonDB free tier (2 * 3 replicas = 6 conn)
    env_file:
      - ./apps/trip-service/.env
    # ports:
    #   - "50053:50053"  # ❌ Disabled for scaling (avoids port conflicts)
    networks:
      - uit-go-network
    deploy:
      replicas: 3  # ✅ Scaled to 3 instances for load balancing
      resources:
        limits:
          cpus: '0.6'                # ✅ High CPU to hammer Redis
          memory: 300M               # ✅ Reduced from 768M to fit 4GB RAM host
        reservations:
          cpus: '0.25'
          memory: 150M
    mem_swappiness: 0
    restart: unless-stopped

  # MQTT Broker - For driver location updates
  mosquitto:
    image: eclipse-mosquitto:2
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ./config/mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf
    networks:
      - uit-go-network
      - app-monitor-net  # ✅ Added for mosquitto-exporter access
    deploy:
      replicas: 1
      resources:
        limits:
          cpus: '0.2'
          memory: 128M       # ✅ Reduced from 256M to fit 4GB RAM host
        reservations:
          cpus: '0.1'
          memory: 64M
    mem_swappiness: 0
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mosquitto_pub", "-h", "localhost", "-t", "health", "-m", "ok", "-q", "1"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  uit-go-network:
    driver: bridge
  app-monitor-net:
    external: true  # ✅ Shared network with observability stack

# ============================================================================
# OPTIMIZED RESOURCE ALLOCATION FOR 4GB RAM HOST
# ============================================================================
# ⚠️ TUNED FOR 4GB RAM HOST - Prevents OOM Kills while maintaining Redis bottleneck
#
# Service          | CPU Limit | Memory Limit | Replicas | Total CPUs | Total Memory
# -----------------|-----------|--------------|----------|------------|-------------
# redis            | 0.5       | 256M         | 1        | 0.5        | 256M
# api-gateway      | 0.5       | 300M         | 1        | 0.5        | 300M
# user-service     | 0.6       | 300M         | 3        | 1.8        | 900M
# driver-service   | 0.6       | 350M         | 3        | 1.8        | 1050M
# trip-service     | 0.6       | 300M         | 3        | 1.8        | 900M
# mosquitto        | 0.2       | 128M         | 1        | 0.2        | 128M
# -----------------|-----------|--------------|----------|------------|-------------
# TOTAL            | -         | -            | 12       | 6.6 CPUs   | 3534M (~3.5GB)
#
# ✅ BOTTLENECK ARCHITECTURE PRESERVED:
#    - Redis: 0.5 CPU (THE BOTTLENECK for driver matching algorithm)
#    - App Services: 6.1 CPUs attacking 0.5 CPU Redis = guaranteed bottleneck
#    - Total Memory: ~3.5GB (fits in 4GB RAM with ~500MB for host OS)
#
# ✅ DATABASE CONNECTION LIMITS:
#    - Each service: 2 connections max (DATABASE_CONNECTION_LIMIT=2)
#    - Total: 3 services × 3 replicas × 2 conn = 18 connections
#    - Fits within NeonDB Free Tier limit (~20-50 connections)
#
# ✅ GHOST DRIVER STRATEGY:
#    - IDs starting with 'ghost:' bypass Clerk and NeonDB completely
#    - Ghost drivers only exist in Redis for geospatial bottleneck testing
#    - Allows 100k+ virtual drivers without hitting database limits
# ============================================================================

# ============================================================================
# HOW TO USE FOR ARCHITECTURAL COMPARISON
# ============================================================================
# SCENARIO 1: Pre-Improvements (Baseline)
#   - Use synchronous gRPC calls only
#   - No caching optimizations
#   - Basic error handling
#   - Run: docker-compose up --build -d
#   - Test: k6 run load-tests/baseline-test.js
#
# SCENARIO 2: Post-Improvements
#   - Async patterns (if implemented)
#   - Caching strategies
#   - Circuit breakers, retries
#   - Run: docker-compose up --build -d
#   - Test: k6 run load-tests/optimized-test.js
#
# COMPARISON:
#   - Same resources (2.5 CPUs, 4GB)
#   - Same replicas (1 per service)
#   - Only architectural differences matter
# ============================================================================
